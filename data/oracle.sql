CREATE USER bank_svc IDENTIFIED BY password;
GRANT CONNECT, RESOURCE, DBA TO bank_svc;

CREATE TABLE bank_svc.customer (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR2(100) NOT NULL,
  email VARCHAR2(100) UNIQUE NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE bank_svc.account (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  balance DECIMAL(15, 2) NOT NULL,
  customer_id NUMBER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
  CONSTRAINT fk_account_customer
    FOREIGN KEY (customer_id)
    REFERENCES bank_svc.customer(id)
);

CREATE OR REPLACE TRIGGER bank_svc.customer_updated_at_trigger
BEFORE UPDATE ON bank_svc.customer
FOR EACH ROW
BEGIN
  :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER bank_svc.account_updated_at_trigger
BEFORE UPDATE ON bank_svc.account
FOR EACH ROW
BEGIN
  :NEW.updated_at := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE PROCEDURE bank_svc.open_account (
    p_name IN VARCHAR2,
    p_email IN VARCHAR2,
    p_initial_balance IN DECIMAL,
    p_customer_id OUT NUMBER,
    p_account_id OUT NUMBER
)
AS
BEGIN
    INSERT INTO bank_svc.customer (name, email)
    VALUES (p_name, p_email)
    RETURNING id INTO p_customer_id;
    
    INSERT INTO bank_svc.account (balance, customer_id)
    VALUES (p_initial_balance, p_customer_id)
    RETURNING id INTO p_account_id;
    
    COMMIT;
    
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

CREATE OR REPLACE PROCEDURE bank_svc.make_transfer (
  p_from_account_id IN NUMBER,
  p_to_account_id IN NUMBER,
  p_amount IN DECIMAL
)
AS
  v_from_balance DECIMAL(15, 2);
  v_to_balance DECIMAL(15, 2);
  v_from_exists NUMBER;
  v_to_exists NUMBER;
  
  insufficient_funds EXCEPTION;
  account_not_found EXCEPTION;
  invalid_amount EXCEPTION;
  same_account EXCEPTION;
BEGIN
  IF p_amount <= 0 THEN
    RAISE invalid_amount;
  END IF;
  
  IF p_from_account_id = p_to_account_id THEN
    RAISE same_account;
  END IF;
  
  -- Check that source account exists (and lock row).
  SELECT balance INTO v_from_balance
  FROM bank_svc.account
  WHERE id = p_from_account_id
  FOR UPDATE;
  
  -- Check that destination account exists (and lock row).
  SELECT balance INTO v_to_balance
  FROM bank_svc.account
  WHERE id = p_to_account_id
  FOR UPDATE;
  
  -- Check for sufficient funds in source account.
  IF v_from_balance < p_amount THEN
    RAISE insufficient_funds;
  END IF;
  
  -- Perform the transfer.
  UPDATE bank_svc.account
  SET balance = balance - p_amount
  WHERE id = p_from_account_id;
  
  UPDATE bank_svc.account
  SET balance = balance + p_amount
  WHERE id = p_to_account_id;
  
  COMMIT;
      
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    ROLLBACK;
    RAISE_APPLICATION_ERROR(-20001, 'One or both accounts not found');
      
  WHEN insufficient_funds THEN
    ROLLBACK;
    RAISE_APPLICATION_ERROR(-20002, 'Insufficient funds in source account');
      
  WHEN invalid_amount THEN
    ROLLBACK;
    RAISE_APPLICATION_ERROR(-20003, 'Transfer amount must be greater than zero');
      
  WHEN same_account THEN
    ROLLBACK;
    RAISE_APPLICATION_ERROR(-20004, 'Cannot transfer to the same account');
      
  WHEN OTHERS THEN
    ROLLBACK;
    RAISE;
END;
/

DECLARE
  v_customer_id NUMBER;
  v_account_id NUMBER;
  v_name VARCHAR2(100);
  v_email VARCHAR2(100);
  v_balance DECIMAL(15, 2);
BEGIN
  FOR i IN 1..1000 LOOP
    v_name := 'customer ' || i;
    v_email := 'customer' || i || '@example.com';
    v_balance := ROUND(DBMS_RANDOM.VALUE(10000, 100000), 2);
    
    bank_svc.open_account(
      p_name => v_name,
      p_email => v_email,
      p_initial_balance => v_balance,
      p_customer_id => v_customer_id,
      p_account_id => v_account_id
    );
  END LOOP;
  
  COMMIT;
END;
/